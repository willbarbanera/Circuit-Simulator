<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Breadboard Lab</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; background: #2c3e50; color: #ecf0f1; margin: 0; overflow: hidden; }
        #toolbar { background: #1a252f; padding: 15px; width: 100%; display: flex; gap: 12px; justify-content: center; border-bottom: 4px solid #34495e; z-index: 10; }
        .tool { padding: 10px 18px; background: #34495e; border: 1px solid #555; color: #fff; cursor: pointer; border-radius: 6px; font-weight: bold; }
        .tool:hover { background: #1abc9c; }
        canvas { background: #ecf0f1; border-radius: 8px; margin-top: 20px; cursor: crosshair; box-shadow: 0 0 40px rgba(0,0,0,0.5); border: 10px solid #bdc3c7; }
        .hint { margin-top: 10px; color: #bdc3c7; font-size: 0.9em; text-align: center; }
    </style>
</head>
<body>

<div id="toolbar">
    <button class="tool" onclick="spawn('battery')">ðŸ”‹ Battery</button>
    <button class="tool" onclick="spawn('bulb')">ðŸ’¡ Bulb</button>
    <button class="tool" onclick="spawn('wire')">ðŸ§µ Wire</button>
    <button class="tool" onclick="spawn('switch')">ðŸ”Œ Switch</button>
    <button class="tool" onclick="clearLab()" style="background: #c0392b;">Reset</button>
</div>

<canvas id="circuitCanvas" width="900" height="500"></canvas>
<p class="hint">Drag <b>handles</b> to stretch/shorten. Drag the <b>center</b> to move. Red/Blue dots must touch the <b>grey prongs</b>.</p>

<script>
    const canvas = document.getElementById('circuitCanvas');
    const ctx = canvas.getContext('2d');

    let components = [];
    let dragTarget = null;
    let currentFlow = 0;
    let eOffset = 0;

    // Create a grid of prongs
    const prongs = [];
    const spacing = 40;
    for (let x = spacing; x < canvas.width; x += spacing) {
        for (let y = spacing; y < canvas.height; y += spacing) {
            prongs.push({ x, y });
        }
    }

    function spawn(type) {
        components.push({
            type,
            x1: 400, y1: 240, // Left handle
            x2: 520, y2: 240, // Right handle
            v: type === 'battery' ? 12 : 0,
            isOpen: type === 'switch' ? true : false,
            active: false
        });
    }

    function checkCircuit() {
        // Find if a path exists between components via shared prongs
        // Simplified: check if at least one battery and one bulb are touching common points
        let hasPower = components.some(c => c.type === 'battery' && c.v > 0);
        let hasBulb = components.some(c => c.type === 'bulb');
        
        // Check if terminals are aligned with prongs
        components.forEach(c => {
            c.p1 = prongs.some(p => Math.hypot(c.x1 - p.x, c.y1 - p.y) < 10);
            c.p2 = prongs.some(p => Math.hypot(c.x2 - p.x, c.y2 - p.y) < 10);
        });

        const allConnected = components.every(c => c.p1 && c.p2);
        const swOpen = components.some(c => c.type === 'switch' && c.isOpen);
        
        return (hasPower && hasBulb && allConnected && !swOpen) ? 1.5 : 0;
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        currentFlow = checkCircuit();

        // 1. Draw Prongs (The background sockets)
        ctx.fillStyle = "#95a5a6";
        prongs.forEach(p => {
            ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI * 2); ctx.fill();
        });

        // 2. Draw Components
        components.forEach(c => {
            const dx = c.x2 - c.x1;
            const dy = c.y2 - c.y1;
            const angle = Math.atan2(dy, dx);
            const dist = Math.hypot(dx, dy);

            ctx.save();
            ctx.translate(c.x1, c.y1);
            ctx.rotate(angle);

            // Draw component body based on stretched length
            if (c.type === 'wire') {
                ctx.strokeStyle = currentFlow > 0 ? "#3498db" : "#34495e";
                ctx.lineWidth = 8;
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(dist, 0); ctx.stroke();
            } else {
                // Body
                ctx.fillStyle = (c.type === 'battery') ? "#2c3e50" : (c.type === 'bulb') ? "#bdc3c7" : "#7f8c8d";
                ctx.fillRect(10, -15, dist - 20, 30);
                
                if (c.type === 'bulb' && currentFlow > 0) {
                    ctx.shadowBlur = 25; ctx.shadowColor = "yellow";
                    ctx.fillStyle = "#f1c40f";
                    ctx.beginPath(); ctx.arc(dist/2, 0, 15, 0, 7); ctx.fill();
                    ctx.shadowBlur = 0;
                }
                if (c.type === 'switch' && c.isOpen) {
                    ctx.strokeStyle = "#fff"; ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(dist/2, -20); ctx.stroke();
                }
            }
            ctx.restore();

            // Draw interactive terminals
            ctx.fillStyle