<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magnetic Breadboard Lab</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; background: #2c3e50; color: #ecf0f1; margin: 0; overflow: hidden; }
        #toolbar { background: #1a252f; padding: 15px; width: 100%; display: flex; gap: 12px; justify-content: center; border-bottom: 4px solid #34495e; z-index: 10; }
        .tool { padding: 10px 18px; background: #34495e; border: 1px solid #555; color: #fff; cursor: pointer; border-radius: 6px; font-weight: bold; }
        .tool:hover { background: #1abc9c; }
        canvas { background: #ecf0f1; border-radius: 8px; margin-top: 20px; cursor: crosshair; box-shadow: 0 0 40px rgba(0,0,0,0.5); border: 10px solid #bdc3c7; }
        .hint { margin-top: 10px; color: #bdc3c7; font-size: 0.9em; text-align: center; }
    </style>
</head>
<body>

<div id="toolbar">
    <button class="tool" onclick="spawn('battery')">ðŸ”‹ Battery</button>
    <button class="tool" onclick="spawn('bulb')">ðŸ’¡ Bulb</button>
    <button class="tool" onclick="spawn('wire')">ðŸ§µ Wire</button>
    <button class="tool" onclick="spawn('switch')">ðŸ”Œ Switch</button>
    <button class="tool" onclick="clearLab()" style="background: #c0392b;">Reset</button>
</div>

<canvas id="circuitCanvas" width="900" height="500"></canvas>
<p class="hint">Terminals will <b>snap</b> to prongs when close. Green dots = Connected.</p>

<script>
    const canvas = document.getElementById('circuitCanvas');
    const ctx = canvas.getContext('2d');

    let components = [];
    let dragTarget = null;
    let currentFlow = 0;
    let eOffset = 0;
    const SNAP_DIST = 20;

    // Create a grid of prongs
    const prongs = [];
    const spacing = 40;
    for (let x = spacing; x < canvas.width; x += spacing) {
        for (let y = spacing; y < canvas.height; y += spacing) {
            prongs.push({ x, y });
        }
    }

    function spawn(type) {
        // Find a starting prong near center
        components.push({
            type,
            x1: 400, y1: 240,
            x2: 520, y2: 240,
            v: type === 'battery' ? 12 : 0,
            isOpen: type === 'switch' ? true : false,
            p1: false, p2: false
        });
    }

    // Helper to find nearest prong
    function getNearestProng(x, y) {
        let nearest = null;
        let minDist = SNAP_DIST;
        prongs.forEach(p => {
            let d = Math.hypot(x - p.x, y - p.y);
            if (d < minDist) {
                minDist = d;
                nearest = p;
            }
        });
        return nearest;
    }

    function checkCircuit() {
        let hasPower = components.some(c => c.type === 'battery' && c.v > 0 && c.p1 && c.p2);
        let hasBulb = components.some(c => c.type === 'bulb' && c.p1 && c.p2);
        
        // Simple connectivity check: are all components properly plugged in?
        const allConnected = components.every(c => c.p1 && c.p2);
        const swOpen = components.some(c => c.type === 'switch' && c.isOpen);
        
        return (hasPower && hasBulb && allConnected && !swOpen) ? 1.5 : 0;
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        currentFlow = checkCircuit();

        // 1. Draw Prongs
        ctx.fillStyle = "#bdc3c7";
        prongs.forEach(p => {
            ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI * 2); ctx.fill();
        });

        // 2. Draw Components
        components.forEach(c => {
            const dx = c.x2 - c.x1;
            const dy = c.y2 - c.y1;
            const angle = Math.atan2(dy, dx);
            const dist = Math.hypot(dx, dy);

            ctx.save();
            ctx.translate(c.x1, c.y1);
            ctx.rotate(angle);

            if (c.type === 'wire') {
                ctx.strokeStyle = currentFlow > 0 ? "#3498db" : "#34495e";
                ctx.lineWidth = 10;
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(dist, 0); ctx.stroke();
            } else {
                ctx.fillStyle = (c.type === 'battery') ? "#2c3e50" : (c.type === 'bulb') ? "#bdc3c7" : "#7f8c8d";
                ctx.fillRect(5, -15, dist - 10, 30);
                
                if (c.type === 'bulb' && currentFlow > 0) {
                    ctx.shadowBlur = 25; ctx.shadowColor = "yellow";
                    ctx.fillStyle = "#f1c40f";
                    ctx.beginPath(); ctx.arc(dist/2, 0, 18, 0, 7); ctx.fill();
                    ctx.shadowBlur = 0;
                }
                if (c.type === 'switch' && c.isOpen) {
                    ctx.strokeStyle = "#fff"; ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(dist/2, -22); ctx.stroke();
                }
            }
            ctx.restore();

            // Terminal Indicators (Snap status)
            ctx.fillStyle = c.p1 ? "#2ecc71" : "#e74c3c";
            ctx.beginPath(); ctx.arc(c.x1, c.y1, 8, 0, 7); ctx.fill();
            ctx.fillStyle = c